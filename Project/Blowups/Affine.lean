import Project.Dilatation.Multicenter
import Mathlib.Data.Sum.Basic
import Project.Dilatation.ReesAlgebra
import Mathlib.RingTheory.Ideal.Maps
import Mathlib.Algebra.DirectSum.Basic
import Project.Dilatation.lemma
import Mathlib.RingTheory.Ideal.Operations
import Mathlib.RingTheory.Localization.Basic
import Project.Dilatation.Family
import Mathlib.RingTheory.GradedAlgebra.Basic
import Mathlib.RingTheory.TensorProduct.Basic
import Project.HomogeneousSubmonoid.Basic
import Project.ForMathlib.TensorProduct
import Project.Proj.Over
import Project.Dilatation.Multicenter


suppress_compilation
universe u
variable {A : Type u} [CommRing A]
variable {ι : Type u} [Fintype ι] (L : ι → Ideal A)
[DecidableEq ι]
variable [(i : ι →₀ ℤ) → Decidable (i ∈ Set.range (ρNatToInt ι))]


open GoodPotionIngredient
def Bl  := Proj
  (τ := GoodPotionIngredient (gradingOfInjection (ReesAlgebra.grading L)
    (ρNatToInt ι)) ) id


structure Mu where
multicenter: Multicenter A
Ψ : multicenter.index → ι
surj : Function.Surjective Ψ
cond : ∀ i, multicenter.LargeIdeal i = L (Ψ i)



@[simps]
def union_center (F F': Multicenter A): Multicenter A :=
  { index := F.index ⊕ F'.index
    ideal := fun i => match i with
      | Sum.inl i => F.ideal i
      | Sum.inr i => F'.ideal i
    elem := fun i => match i with
      | Sum.inl i => F.elem i
      | Sum.inr i => F'.elem i
    }
@[simp]
lemma union_center_largeIdeal_left (F F' : Multicenter A) (i : F.index) :
 (union_center F F').LargeIdeal (Sum.inl i) = F.LargeIdeal i := rfl

@[simp]
lemma union_center_largeIdeal_right (F F' : Multicenter A) (i : F'.index) :
 (union_center F F').LargeIdeal (Sum.inr i) = F'.LargeIdeal i := rfl

def union_Mu (P P' : Mu L) : Mu L :=
  { multicenter := union_center P.multicenter P'.multicenter,
    Ψ := Sum.rec (P.Ψ) (P'.Ψ),
    surj := by
      rintro i
      obtain ⟨ a, ha⟩ := P.surj i
      use Sum.inl a
    cond := by
          rintro (i|i)
          · simp [P.cond i]
          · simp [P'.cond i] }


def clo_mu (P: Mu L) : HomogeneousSubmonoid (ReesAlgebra.grading L):=
    HomogeneousSubmonoid.closure _ _



lemma Mu_rel (P: Mu L) :
 Submonoid.closure  {.of _ e_i P.multicenter.elem  i |i : P.multicenter.index}
     is (i : ι →₀ ℤ)-relevant in ReesAlgebra L  := by
     P.multicenter.elem i belongs to L Ψ i and has degree e_i. Use that Ψ is surjective.
     The group generated by the e_i is (i : ι →₀ ℤ)
     sorry



def Mu_mor (P: Mu L):
  A[P.multicenter] →ₐ[A] Potion {.of _ e_i P.multicenter.elem  i |i : P.multicenter.index} ReesAlgebra L := by
   desc F.Multicenter
    (by
     -- apply that s is nonzero in Potion (A,S)
     )
    (by
      let i ∈ F.index
      Then (a) ⊆ (L_i) is trivial, so same holds for image
      Reciprocally, we write m=m/a .a.
      )

lemma Mu_mor_iso (P: Mu L ): Mu_mor is an iso :=
  by  injective surjective
   sorry


 sorry


def Po (P: Mu) : open subscheme of Bl :=
    Spec(Potion P in Rees)

lemma inter_Po (P,P' : Mu L) : Po.P ∩ Po.P' = Po.union.Mu P P' (as open subschemes) := by
   many already stasblished lemmas
   sorry



lemma Dila_cov_proj : ∪ (F: Mu) dila F
                     = Bl L  :=
     --in the paper
    sorry


lemma lemm_dila :  (f: A →+*B) (P P': Mu) (c: nonzerodiv B)
(g: A[P]→ B)
(g':  A[P']→ B)
(cond1: Ideal.map (f) (L) = Ideal.span {c})
(cond2: f= g (algebramap A A[P] ) )
(cond2': f= g' (algebramap A A[P'] ) ) :
∃! g''A[union_center P P'] →ₐ[A]B such that ....


lemma ProjBlowup_UnivProp_unicity_affine : [Scheme T Spec(A)]
(φ φ': T →over Spec(A) Bl L ): φ=φ' := by
  Let x ∈ T.
  Reduce to local neighborhood
  put y=φx
  put y'=φ'x
  obtain P ∈ Mu L such that y ∈ Mu P
  obtain p' ∈ Mu L such that y ∈ Mu P'
  Let U=Spec(B) be an affine neighborhood of x in φ^-1 (Po P) ∩ φ'^-1 (Po P').
  consider the restrictions of φ and φ' to U
  Phi factors through Po P, Phi' factors through Po P'
  apply lemma 2
  apply univ prop of dilatations
  sorry

/-obtain ⟨j, x, rfl⟩ := (glueData ℱ).ι_jointly_surjective x
  obtain ⟨j', x', rfl⟩ := (glueData ℱ).ι_jointly_surjective x'-/
