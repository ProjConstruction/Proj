import Project.Dilatation.Multicenter
import Mathlib.Data.Sum.Basic
import Project.Dilatation.ReesAlgebra
import Mathlib.RingTheory.Ideal.Maps
import Mathlib.Algebra.DirectSum.Basic
import Project.Dilatation.lemma
import Mathlib.RingTheory.Ideal.Operations
import Mathlib.RingTheory.Localization.Basic
import Project.Dilatation.Family
import Mathlib.RingTheory.GradedAlgebra.Basic
import Mathlib.RingTheory.TensorProduct.Basic
import Project.HomogeneousSubmonoid.Basic
import Project.ForMathlib.TensorProduct
import Project.Proj.Over
import Project.Dilatation.Multicenter


suppress_compilation
universe u
variable {A : Type u} [CommRing A]
variable {ι : Type u} [Fintype ι] (L : ι → Ideal A)
[DecidableEq ι]
variable [(i : ι →₀ ℤ) → Decidable (i ∈ Set.range (ρNatToInt ι))]


open GoodPotionIngredient
def Bl  := Proj (τ := GoodPotionIngredient (ReesAlgebra.intGrading L)) id


structure Mu where
multicenter: Multicenter A
Ψ : multicenter.index → ι
sec : ι → multicenter.index
surj : ∀ i, Ψ (sec i) = i
cond : ∀ i, multicenter.LargeIdeal i = L (Ψ i)



@[simps]
def union_center (F F': Multicenter A): Multicenter A :=
  { index := F.index ⊕ F'.index
    ideal := fun i => match i with
      | Sum.inl i => F.ideal i
      | Sum.inr i => F'.ideal i
    elem := fun i => match i with
      | Sum.inl i => F.elem i
      | Sum.inr i => F'.elem i
    }
@[simp]
lemma union_center_largeIdeal_left (F F' : Multicenter A) (i : F.index) :
 (union_center F F').LargeIdeal (Sum.inl i) = F.LargeIdeal i := rfl

@[simp]
lemma union_center_largeIdeal_right (F F' : Multicenter A) (i : F'.index) :
 (union_center F F').LargeIdeal (Sum.inr i) = F'.LargeIdeal i := rfl

def union_Mu (P P' : Mu L) : Mu L :=
  { multicenter := union_center P.multicenter P'.multicenter,
    Ψ := Sum.rec (P.Ψ) (P'.Ψ),
    sec := Sum.inl ∘ P.sec
    surj := by
      intro i
      simpa [union_center_index, Function.comp_apply] using P.surj i
    cond := by
      rintro (i|i)
      · simp [P.cond i]
      · simp [P'.cond i] }

def clo_mu (P: Mu L) [DecidableEq P.multicenter.index] :
    HomogeneousSubmonoid (ReesAlgebra.intGrading L):=
  HomogeneousSubmonoid.closure
      { ReesAlgebra.single L (Finsupp.single (P.Ψ i) 1) ⟨P.multicenter.elem i, by
        rw [familyPow_single, ← P.cond i]
        apply Multicenter.elem_mem_LargeIdeal⟩ | (i : P.multicenter.index) } <| by
  rintro _ ⟨i, rfl⟩
  use (Finsupp.single (P.Ψ i) 1)
  simp only [ReesAlgebra.intGrading, gradingOfInjection, Set.mem_range, ρNatToInt_apply]
  split_ifs with h
  · rcases h with ⟨n, hn⟩
    have eq₀ : n = Finsupp.single (P.Ψ i) 1 := by
      ext j
      rw [Finsupp.ext_iff] at hn
      specialize hn j
      simp only [Finsupp.single_apply] at hn ⊢
      split_ifs at hn ⊢ with h
      · simpa [ρNatToInt] using hn
      · simpa [ρNatToInt] using hn

    refine ⟨⟨P.multicenter.elem i, ?_⟩, ?_⟩
    · simp_rw [← hn]
      generalize_proofs _ h1
      have eq : Set.rangeSplitting ⇑(ρNatToInt ι) ⟨(ρNatToInt ι) n, h1⟩ = n := by
        apply ρNatToInt_inj
        rw [Set.apply_rangeSplitting (ρNatToInt ι)]
      rw [eq, eq₀]

      rw [familyPow_single, ← P.cond i]
      apply Multicenter.elem_mem_LargeIdeal

    · apply ReesAlgebra.single_eq
      subst eq₀
      apply ρNatToInt_inj
      simp_rw [← hn]
      rw [Set.apply_rangeSplitting (ρNatToInt ι)]
  · refine h ?_ |>.elim
    use Finsupp.single (P.Ψ i) 1
    ext j
    simp [ρNatToInt]


lemma Mu_rel (P: Mu L) [DecidableEq P.multicenter.index]  : (clo_mu L P).IsRelevant := by
  rw [HomogeneousSubmonoid.isRelevant_iff_finiteIndex_of_FG]
    --  P.multicenter.elem i belongs to L Ψ i and has degree e_i. Use that Ψ is surjective.
    --  The group generated by the e_i is (i : ι →₀ ℤ)
  sorry

-- A -> (Rees L)[0] -> (clo_mu L P).Potion
def mu_potion_algebraMap (P: Mu L) [DecidableEq P.multicenter.index] :
    A →+* ((clo_mu L P).Potion) :=
  RingHom.comp (algebraMap _ _) (ReesAlgebra.degreeZeroIso' L |>.toRingHom)


instance (P: Mu L) [DecidableEq P.multicenter.index] : Algebra A ((clo_mu L P).Potion) :=
  RingHom.toAlgebra (mu_potion_algebraMap L P)

omit [Fintype ι] in
lemma mu_potion_algebraMap_eq (P: Mu L) [DecidableEq P.multicenter.index] :
  algebraMap A (clo_mu L P).Potion = mu_potion_algebraMap L P := rfl

open Multicenter Multicenter.Dilatation
def Mu_mor (P: Mu L) [DecidableEq P.multicenter.index] :
  A[P.multicenter] →ₐ[A] (clo_mu L P).Potion :=
   Multicenter.desc P.multicenter
    (by
     -- apply that s is nonzero in Potion (A,S)
     sorry
     )
    (by
      -- let i ∈ F.index
      -- Then (a) ⊆ (L_i) is trivial, so same holds for image
      -- Reciprocally, we write m=m/a .a.
      sorry)

lemma Mu_mor_iso (P: Mu L ): Mu_mor is an iso :=
  by  injective surjective
   sorry


 sorry


def Po (P: Mu) : open subscheme of Bl :=
    Spec(Potion P in Rees)

lemma inter_Po (P,P' : Mu L) : Po.P ∩ Po.P' = Po.union.Mu P P' (as open subschemes) := by
   many already stasblished lemmas
   sorry



lemma Dila_cov_proj : ∪ (F: Mu) dila F
                     = Bl L  :=
     --in the paper
    sorry


lemma lemm_dila :  (f: A →+*B) (P P': Mu) (c: nonzerodiv B)
(g: A[P]→ B)
(g':  A[P']→ B)
(cond1: Ideal.map (f) (L) = Ideal.span {c})
(cond2: f= g (algebramap A A[P] ) )
(cond2': f= g' (algebramap A A[P'] ) ) :
∃! g''A[union_center P P'] →ₐ[A]B such that ....


lemma ProjBlowup_UnivProp_unicity_affine : [Scheme T Spec(A)]
(φ φ': T →over Spec(A) Bl L ): φ=φ' := by
  Let x ∈ T.
  Reduce to local neighborhood
  put y=φx
  put y'=φ'x
  obtain P ∈ Mu L such that y ∈ Mu P
  obtain p' ∈ Mu L such that y ∈ Mu P'
  Let U=Spec(B) be an affine neighborhood of x in φ^-1 (Po P) ∩ φ'^-1 (Po P').
  consider the restrictions of φ and φ' to U
  Phi factors through Po P, Phi' factors through Po P'
  apply lemma 2
  apply univ prop of dilatations
  sorry

/-obtain ⟨j, x, rfl⟩ := (glueData ℱ).ι_jointly_surjective x
  obtain ⟨j', x', rfl⟩ := (glueData ℱ).ι_jointly_surjective x'-/
